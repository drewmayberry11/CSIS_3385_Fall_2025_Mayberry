The important fix was structural, by turning the form method to POST from DELETE, it restored a visual of input type='password' and set in place every <label for> with it's matching id while keeping the names attributes meaningful. Those changes are made sure that the browser can submit the form, screen readers could announce fields as intended, and the server could handles predictable keys.

As for the validation, the HTML5 holds in place light java script, and I set types, such as email, text, password, and number, set them as key fields that are required, while adding a max, min, max length, and used a username pattern where useful. There is a small JS script with a 10 word limit with space separated tokens, as well as block submission with a friendly error. common sense was used with these rules and were chosen to match the inputs while stopping obviously bad submissions without being overly strict.

A specific security issue brought to attention was DOM/XSS risk from the free text fields. On the client side I decided to avoid using innerHTML, and the surface message using text only nodes. The server side (not shown but as recommended) the inputs should be validated, while the outputs are encoded before the rendering. Using POST and a field that has clear semiotics, it reduces the data leak surprises and injections.

I would say if this was production code I would add CRSF tokens, limiting the rate of CAPTCHA for control abuse. HTTPS only transportation, server side validation, as well as an audit logging with a graceful, yet not revealing error message.
